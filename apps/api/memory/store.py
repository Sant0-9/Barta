"""Memory store for conversation management"""

import uuid
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy import text
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


def start_conversation(db: Session) -> str:
    """
    Start a new conversation and return its UUID.
    
    Args:
        db: Database session
        
    Returns:
        str: UUID of the new conversation
    """
    try:
        # Create new conversation - UUID is auto-generated by the database
        result = db.execute(text("INSERT INTO conversations DEFAULT VALUES RETURNING id"))
        conversation_id = result.fetchone()[0]
        db.commit()
        
        logger.info(f"Started new conversation: {conversation_id}")
        return str(conversation_id)
        
    except Exception as e:
        logger.error(f"Failed to start conversation: {e}")
        db.rollback()
        raise


def append_message(db: Session, conversation_id: str, role: str, content: str) -> None:
    """
    Append a message to a conversation.
    
    Args:
        db: Database session
        conversation_id: UUID of the conversation
        role: Message role ('user' or 'assistant')
        content: Message content
    """
    try:
        # Validate role
        if role not in ['user', 'assistant', 'tool']:
            raise ValueError(f"Invalid role: {role}")
        
        # Insert message
        db.execute(
            text("""
                INSERT INTO messages (conversation_id, role, content)
                VALUES (:conversation_id, :role, :content)
            """),
            {
                "conversation_id": conversation_id,
                "role": role,
                "content": content
            }
        )
        db.commit()
        
        logger.debug(f"Appended {role} message to conversation {conversation_id}")
        
    except Exception as e:
        logger.error(f"Failed to append message: {e}")
        db.rollback()
        raise


def get_recent_messages(db: Session, conversation_id: str, limit: int = 8) -> List[Dict[str, Any]]:
    """
    Get recent messages from a conversation.
    
    Args:
        db: Database session
        conversation_id: UUID of the conversation
        limit: Maximum number of messages to return
        
    Returns:
        List of message dictionaries with 'role' and 'content' keys
    """
    try:
        # Validate UUID format first
        import uuid
        try:
            uuid.UUID(conversation_id)
        except ValueError:
            logger.warning(f"Invalid UUID format for message retrieval: {conversation_id}")
            return []
            
        result = db.execute(
            text("""
                SELECT role, content, created_at
                FROM messages 
                WHERE conversation_id = :conversation_id
                ORDER BY created_at DESC
                LIMIT :limit
            """),
            {
                "conversation_id": conversation_id,
                "limit": limit
            }
        )
        
        messages = []
        for row in reversed(result.fetchall()):  # Reverse to get chronological order
            messages.append({
                "role": row[0],
                "content": row[1],
                "created_at": row[2]
            })
        
        logger.debug(f"Retrieved {len(messages)} recent messages for conversation {conversation_id}")
        return messages
        
    except Exception as e:
        logger.error(f"Failed to get recent messages: {e}")
        db.rollback()  # Rollback transaction on error
        return []


def get_summary(db: Session, conversation_id: str) -> Optional[str]:
    """
    Get the summary for a conversation.
    
    Args:
        db: Database session
        conversation_id: UUID of the conversation
        
    Returns:
        Summary text or None if no summary exists
    """
    try:
        # Validate UUID format first
        import uuid
        try:
            uuid.UUID(conversation_id)
        except ValueError:
            logger.warning(f"Invalid UUID format for summary retrieval: {conversation_id}")
            return None
            
        result = db.execute(
            text("""
                SELECT short_summary 
                FROM conversation_memory 
                WHERE conversation_id = :conversation_id
            """),
            {"conversation_id": conversation_id}
        )
        
        row = result.fetchone()
        if row and row[0]:
            logger.debug(f"Retrieved summary for conversation {conversation_id}")
            return row[0]
        
        logger.debug(f"No summary found for conversation {conversation_id}")
        return None
        
    except Exception as e:
        logger.error(f"Failed to get summary: {e}")
        db.rollback()  # Rollback transaction on error
        return None


def set_summary(db: Session, conversation_id: str, summary_text: str) -> None:
    """
    Set or update the summary for a conversation.
    
    Args:
        db: Database session
        conversation_id: UUID of the conversation
        summary_text: Summary text
    """
    try:
        # Use UPSERT (INSERT ... ON CONFLICT) to handle both insert and update
        db.execute(
            text("""
                INSERT INTO conversation_memory (conversation_id, short_summary, last_updated)
                VALUES (:conversation_id, :summary_text, NOW())
                ON CONFLICT (conversation_id)
                DO UPDATE SET 
                    short_summary = EXCLUDED.short_summary,
                    last_updated = EXCLUDED.last_updated
            """),
            {
                "conversation_id": conversation_id,
                "summary_text": summary_text
            }
        )
        db.commit()
        
        logger.debug(f"Updated summary for conversation {conversation_id}")
        
    except Exception as e:
        logger.error(f"Failed to set summary: {e}")
        db.rollback()
        raise


def conversation_exists(db: Session, conversation_id: str) -> bool:
    """
    Check if a conversation exists.
    
    Args:
        db: Database session
        conversation_id: UUID of the conversation
        
    Returns:
        True if conversation exists, False otherwise
    """
    try:
        # Validate UUID format first
        import uuid
        try:
            uuid.UUID(conversation_id)
        except ValueError:
            logger.warning(f"Invalid UUID format: {conversation_id}")
            return False
        
        result = db.execute(
            text("SELECT 1 FROM conversations WHERE id = :conversation_id"),
            {"conversation_id": conversation_id}
        )
        
        exists = result.fetchone() is not None
        logger.debug(f"Conversation {conversation_id} exists: {exists}")
        return exists
        
    except Exception as e:
        logger.error(f"Failed to check conversation existence: {e}")
        db.rollback()  # Rollback the transaction on error
        return False